---
layout: '../../layouts/MarkdownPost.astro'
title: '[Linux] 网络编程-套接字'
pubDate: 2023-06-25
description: ''
author: '七月.cc'
cover:
    url: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306251756988.png
'
    square: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306251756988.png'
    alt: 'cover'
tags: ["Linux", "网络"]
theme: 'light'
featured: false

---

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306251756988.png)

---

上一篇文章中, 我们简单的介绍了网络的最基础的部分内容, 没有涉及到编程相关的内容.

从本篇文章开始, 就真正开始涉及到网络编程了.

# 网络编程 - 套接字

在正式开始网络编程之前, 还需要介绍几个概念

## 一些概念

### 1. 源ip地址与目的ip地址

不同局域网的主机之间进行通信, 是通过IP地址进行的.

那么, 其中 **`源IP地址 就是发送主机的IP地址, 目的IP地址 就是接收主机的IP地址.`**

要如何理解这两个ip地址呢? 其实就可以看作我们生活中的两个东西, `始发地和最终目的地`.

假如要从家里自驾去某个地方旅游, 首先 家是不会变的, 其次 即使中途可能经过许多地方, 但是正常情况下 你的最终目的地是不会变的. 

### 2. `端口号 和 socket套接字 **`

网络通信 可以看成是两台主机在通信. 不过, 我们在网络通信的时候, 只要将两台主机之间能够通信就可以了吗?

其实不是的, 不仅仅需要考虑两台主机之间相互交互数据.

网络协议栈与主机之间的关系是什么?

![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306252053653.png)

网络层和传输层是属于操作系统的. 更上层的应用层, 是给用户使用的.

而网络通信、数据交互其实就是为用户提供的交互. 无论是朋友之间发送信息还是玩网络游戏. 网络通信, 都是给用户提供的交互.

不过, 虽然操作系统是由用户操作的, 但是 **`在操作系统看来 其实是进程在进行交互`**. 因为用户也是通过某程序 实现的网络通信. 

即本质上, 在操作系统层面, 用户的身份 通常是由程序体现的. 要实现通信, 程序一定是在运行中的, 也就是 **`进程`**

那么, `实际上两台主机进行通信就是通过运行应用层程序进行通信, 也就是 进程在通信、在交互数据`

**`网络通信的本质, 即为 进程间通信`**. 不过不是同一主机内的进程, 而是不同主机的进程.

而 **`端口号`**, 其实就是用来 **`表示唯一进程的标识符`**, 他是传输层协议的内容.

那么, 对当前主机来说:

1. IP地址, 保证了主机的唯一性
2. 端口号(PORT), 保证了主机内进程的唯一性

当IP地址与端口号, 以此格式结合使用 : `IP地址:PORT`, 就可以标识到 `网络中的唯一进程`.

此组合, 也被称为 **`socket 套接字`**

>  **1. 端口号, 是一个2字节16位的整数**  
>
> **2. 一个端口号, 只能被一个进程占用, 即 一个端口号只能标识一个进程**

#### 问题

**`操作系统中, 不是已经存在 PID 的概念 来作为进程的唯一标识符了吗? 为什么还要有端口号? 为什么不直接使用 PID 来确定网络中的唯一进程呢?`**

首先要明白, 技术层面来讲 使用PID直接作为确定网络中唯一进程的标识, 肯定是可行的.

但是, 实际上操作系统中的进程并不都需要网络通信的. 那么直接使用PID来确定网络中的唯一进程, 并不完全契合.

并且, PID 在操作系统中主要是用来 进程管理的. 如果直接使用 PID来确定网络中的唯一进程, 那么 就将操作系统的进程管理和网络强耦合起来了. 这种做法是不明智的.

### 3. 源端口号和目的端口号

我们知道, 源IP地址与目的IP地址 是用来确定主机的.

但是, **`网络通信的本质是 进程间的通信`**. 既然是进程间通信, 那么就`需要确定到` 源主机 和 目的主机 网络上的`进程`

所以就有了 源端口号和目的端口号, 用来确定 `源主机的发送进程和目的主机的接收进程`

### 4. 认识TCP协议基本特点

此处先对TCP(Transmission Control Protocol 传输控制协议)有一个直观的认识. 后面会对TCP协议有一个更细节的介绍.

TCP协议的基本特点:

1. 传输层协议

2. 有连接

    有连接是什么意思呢? 比如, 我们使用SSH连接服务器主机. SSH就是用的TCP协议. 必须要与服务器主机建立连接之后, 才能正常的与服务器进行通信.

3. 可靠传输

    什么是可靠传输? 可靠传输, 并不是一个主观的判断. 而是传输数据时, TCP会使用各种技术防止数据丢失或损坏, 这种实现方式称为可靠传输. 并不表示TCP传输就一定是可靠的.

4. 面向字节流

### 5. 认识UDP协议基本特点

此处也对UDP(User Datagram Protocol 用户数据报协议)有一个直观的认识. 后面再详细讨论

UDP协议的基本特点:

1. 传输层协议

2. 无连接

    无连接, 顾名思义就是通信前, 双方不需要建立连接. 像发电子邮件等, 只要本机有网络可以随时的发送, 不需要与目标方建立连接. 目标方也不用实时接收信息, 想什么时候查看都可以.

3. 不可靠传输

    UDP协议不会确保数据的完整性, 如果传输过程中数据丢失, UDP协议也不会管, 更不会重新发送.

    就像直播时, 如果网络差 很可能会导致画面、音频卡顿、模糊等.

4. 面向数据报

**可靠传输和不可靠传输没有优劣之分, 只有使用场景的合适与不合适. 可靠与不可靠也只是根据传输特点的形容, 而不是实际使用的体验.**

### 6. 网络字节序

内存中的 **多字节数据相对于内存地址有大端和小端之分**, 磁盘文件中的 **多字节数据相对于文件中的偏移地址也有大端小端之分**

---

**`什么是大小端字节序?`**

```
以 内存中存储数据为例.
```

长字节数据在内存中存储时, 不同平台可能存在不同的字节序存储方式:

1. 大端字节序: 数据的高位字节 存储在 内存的低地址处, 低位字节 存储在内存的高地址处

2. 小端字节序: 数据的低位字节 存储在 内存的低地址处, 高位字节 存储在内存的高地址处

    小端字节序存储, 并 **`不是将数据倒序存储`**, 而是 **`以字节为单位`** 从低位数据到高位数据 存储到内存的 低地址到高地址

![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306261642103.png)

既然存储方式不同, 想要正确的读取到数据, 读取的顺序也需要不同.

**使用大端字节序的平台, 读取数据 需要从内存的有效低地址处开始 读取到内存到有效高地址处**

**而使用小端字节序的平台, 读取数据 需要从内存的有效高地址处开始 读取到内存的有效低地址处**

> CPU在读取内存中的数据时, 默认是从有效低地址开始的, 所以小端字节序平台, CPU默认读取到的数据 顺序是错误的.

---

既然 数据的存储不同的平台有大小端字节序之分, 那么 `如果不加以规定, 在网络通信中就有可能无法进行通信`.

如果各自平台都默认使用自己平台字节序的正确读取顺序(小端平台从高地址开始读取, 大端平台从低地址开始读取), 也默认使用自己平台字节序的存储顺序发送数据

那么大端字节序平台就不能正确的读取从小端字节序平台发来的数据, 小端字节序同理, 进而就不可能正常的建立通信.

那么, 网络通信的 网络字节流的地址 该怎么样去定义呢?

1. 发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出;
2. 接收主机把从网络上接到的字节依次保存在接收缓冲区中, 也是按内存地址从低到高的顺序保存;

因此, 网络数据流的地址应这样规定: 先发出的数据是低地址, 后发出的数据是高地址.

并且, **`TCP/IP协议规定: 网络数据流应采用大端字节序, 即低地址处高位字节.`**

不管这台主机是大端机还是小端机, 都要按照这个TCP/IP规定的网络字节序来发送/接收数据;

如果当前发送主机是小端, 就需要先将数据转成大端, 否则就忽略.

因此, **`大端字节序 也叫做 网络字节序`**

网络数据流被规范之后, 网络上流动的数据就恒为大端字节序, 那么 **接收端读取数据 就按照读取大端字节序数据的方式, 或将接收到的数据的存储顺序调整为小端字节序 然后在读取**, 就可以正常的读取到数据了.

> C语言提供了相应的数据转换字节序的接口:
>
> ![ ](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306261749665.png)
>
> 这些接口名很好记, `h` 表示 host, `n` 表示 network, `l` 表示 32位长整型, `s` 表示 16位短整型, `to` 表示 转换为
>
> ```c
> #include <arpa/inet.h>
> 
> // 本机字节序, 转换为网络字节序数据
> uint32_t htonl(uint32_t hostlong);
> uint16_t htons(uint16_t hostshort);
> 
> // 网络字节序, 转换为本机字节序数据
> uint32_t ntohl(uint32_t netlong);
> uint16_t ntohs(uint16_t netshort);
> ```
>
> 转换之后, 会通过返回值返回. 
>
> 如果, 本机就为 大端字节序存储, 则这些接口不会发生转换
