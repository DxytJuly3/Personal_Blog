---
layout: '../../layouts/MarkdownPost.astro'
title: '[Linux] 网络编程-套接字'
pubDate: 2023-06-25
description: ''
author: '七月.cc'
cover:
    url: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306251756988.png
'
    square: 'https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306251756988.png'
    alt: 'cover'
tags: ["Linux", "网络"]
theme: 'light'
featured: false
---

![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306251756988.png)

---

上一篇文章中, 我们简单的介绍了网络的最基础的部分内容, 没有涉及到编程相关的内容.

从本篇文章开始, 就真正开始涉及到网络编程了.

# 网络编程 - 套接字

在正式开始网络编程之前, 还需要介绍几个概念

## 一些概念

### 1. 源ip地址与目的ip地址

不同局域网的主机之间进行通信, 是通过IP地址进行的.

那么, 其中 **`源IP地址 就是发送主机的IP地址, 目的IP地址 就是接收主机的IP地址.`**

要如何理解这两个ip地址呢? 其实就可以看作我们生活中的两个东西, `始发地和最终目的地`.

假如要从家里自驾去某个地方旅游, 首先 家是不会变的, 其次 即使中途可能经过许多地方, 但是正常情况下 你的最终目的地是不会变的. 

### 2. `端口号 和 socket套接字 **`

网络通信 可以看成是两台主机在通信. 不过, 我们在网络通信的时候, 只要将两台主机之间能够通信就可以了吗?

其实不是的, 不仅仅需要考虑两台主机之间相互交互数据.

网络协议栈与主机之间的关系是什么?

![|inline](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306252053653.png)

网络层和传输层是属于操作系统的. 更上层的应用层, 是给用户使用的.

而网络通信、数据交互其实就是为用户提供的交互. 无论是朋友之间发送信息还是玩网络游戏. 网络通信, 都是给用户提供的交互.

不过, 虽然操作系统是由用户操作的, 但是 **`在操作系统看来 其实是进程在进行交互`**. 因为用户也是通过某程序 实现的网络通信. 

即本质上, 在操作系统层面, 用户的身份 通常是由程序体现的. 要实现通信, 程序一定是在运行中的, 也就是 **`进程`**

那么, `实际上两台主机进行通信就是通过运行应用层程序进行通信, 也就是 进程在通信、在交互数据`

**`网络通信的本质, 即为 进程间通信`**. 不过不是同一主机内的进程, 而是不同主机的进程.

而 **`端口号`**, 其实就是用来 **`表示唯一进程的标识符`**, 他是传输层协议的内容.

那么, 对当前主机来说:

1. IP地址, 保证了主机的唯一性
2. 端口号(PORT), 保证了主机内进程的唯一性

当IP地址与端口号, 以此格式结合使用 : `IP地址:PORT`, 就可以标识到 `网络中的唯一进程`.

此组合, 也被称为 **`socket 套接字`**

>  **1. 端口号, 是一个2字节16位的整数**  
>
> **2. 一个端口号, 只能被一个进程占用, 即 一个端口号只能标识一个进程**

#### 问题

**`操作系统中, 不是已经存在 PID 的概念 来作为进程的唯一标识符了吗? 为什么还要有端口号? 为什么不直接使用 PID 来确定网络中的唯一进程呢?`**

首先要明白, 技术层面来讲 使用PID直接作为确定网络中唯一进程的标识, 肯定是可行的.

但是, 实际上操作系统中的进程并不都需要网络通信的. 那么直接使用PID来确定网络中的唯一进程, 并不完全契合.

并且, PID 在操作系统中主要是用来 进程管理的. 如果直接使用 PID来确定网络中的唯一进程, 那么 就将操作系统的进程管理和网络强耦合起来了. 这种做法是不明智的.

### 3. 源端口号和目的端口号

我们知道, 源IP地址与目的IP地址 是用来确定主机的.

但是, **`网络通信的本质是 进程间的通信`**. 既然是进程间通信, 那么就`需要确定到` 源主机 和 目的主机 网络上的`进程`

所以就有了 源端口号和目的端口号, 用来确定 `源主机的发送进程和目的主机的接收进程`

> 结合源IP地址与目的IP地址
>
>  **`源IP:源端口号`** 和 **`目的IP:目的端口号`** 就组成了一个 `socket对`
>
> socket对, 即指 发送端Socket和接收端Socket的组合

### 4. 认识TCP协议基本特点

此处先对TCP(Transmission Control Protocol 传输控制协议)有一个直观的认识. 后面会对TCP协议有一个更细节的介绍.

TCP协议的基本特点:

1. 传输层协议

2. 有连接

    有连接是什么意思呢? 比如, 我们使用SSH连接服务器主机. SSH就是用的TCP协议. 必须要与服务器主机建立连接之后, 才能正常的与服务器进行通信.

3. 可靠传输

    什么是可靠传输? 可靠传输, 并不是一个主观的判断. 而是传输数据时, TCP会使用各种技术防止数据丢失或损坏, 这种实现方式称为可靠传输. 并不表示TCP传输就一定是可靠的.

4. 面向字节流

### 5. 认识UDP协议基本特点

此处也对UDP(User Datagram Protocol 用户数据报协议)有一个直观的认识. 后面再详细讨论

UDP协议的基本特点:

1. 传输层协议

2. 无连接

    无连接, 顾名思义就是通信前, 双方不需要建立连接. 比如, 直播、短视频等. 

3. 不可靠传输

    UDP协议不会确保数据的完整性, 如果传输过程中数据丢失, UDP协议也不会管, 更不会重新发送.

    就像直播时, 如果网络差 很可能会导致画面、音频卡顿、模糊等.

4. 面向数据报

**可靠传输和不可靠传输没有优劣之分, 只有使用场景的合适与不合适. 可靠与不可靠也只是根据传输特点的形容, 而不是实际使用的体验.**

### 6. 网络字节序

内存中的 **多字节数据相对于内存地址有大端和小端之分**, 磁盘文件中的 **多字节数据相对于文件中的偏移地址也有大端小端之分**

---

**`什么是大小端字节序?`**

```
以 内存中存储数据为例.
```

长字节数据在内存中存储时, 不同平台可能存在不同的字节序存储方式:

1. 大端字节序: 数据的高位字节 存储在 内存的低地址处, 低位字节 存储在内存的高地址处

2. 小端字节序: 数据的低位字节 存储在 内存的低地址处, 高位字节 存储在内存的高地址处

    小端字节序存储, 并 **`不是将数据倒序存储`**, 而是 **`以字节为单位`** 从低位数据到高位数据 存储到内存的 低地址到高地址

![|big](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306261642103.png)

既然存储方式不同, 想要正确的读取到数据, 读取的顺序也需要不同.

**使用大端字节序的平台, 读取数据 需要从内存的有效低地址处开始 读取到内存到有效高地址处**

**而使用小端字节序的平台, 读取数据 需要从内存的有效高地址处开始 读取到内存的有效低地址处**

> CPU在读取内存中的数据时, 默认是从有效低地址开始的, 所以小端字节序平台, CPU默认读取到的数据 顺序是错误的.

---

既然 数据的存储不同的平台有大小端字节序之分, 那么 `如果不加以规定, 在网络通信中就有可能无法进行通信`.

如果各自平台都默认使用自己平台字节序的正确读取顺序(小端平台从高地址开始读取, 大端平台从低地址开始读取), 也默认使用自己平台字节序的存储顺序发送数据

那么大端字节序平台就不能正确的读取从小端字节序平台发来的数据, 小端字节序同理, 进而就不可能正常的建立通信.

那么, 网络通信的 网络字节流的地址 该怎么样去定义呢?

1. 发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出;
2. 接收主机把从网络上接到的字节依次保存在接收缓冲区中, 也是按内存地址从低到高的顺序保存;

因此, 网络数据流的地址应这样规定: 先发出的数据是低地址, 后发出的数据是高地址.

并且, **`TCP/IP协议规定: 网络数据流应采用大端字节序, 即低地址处高位字节.`**

不管这台主机是大端机还是小端机, 都要按照这个TCP/IP规定的网络字节序来发送/接收数据;

如果当前发送主机是小端, 就需要先将数据转成大端, 否则就忽略.

因此, **`大端字节序 也叫做 网络字节序`**

网络数据流被规范之后, 网络上流动的数据就恒为大端字节序, 那么 **接收端读取数据 就按照读取大端字节序数据的方式, 或将接收到的数据的存储顺序调整为小端字节序 然后在读取**, 就可以正常的读取到数据了.

> C语言提供了相应的数据转换字节序的接口:
>
> ![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306261749665.png)
>
> 这些接口名很好记, `h` 表示 host, `n` 表示 network, `l` 表示 32位长整型, `s` 表示 16位短整型, `to` 表示 转换为
>
> ```c
> #include <arpa/inet.h>
> 
> // 本机字节序, 转换为网络字节序数据
> uint32_t htonl(uint32_t hostlong);
> uint16_t htons(uint16_t hostshort);
> 
> // 网络字节序, 转换为本机字节序数据
> uint32_t ntohl(uint32_t netlong);
> uint16_t ntohs(uint16_t netshort);
> ```
>
> 转换之后, 会通过返回值返回. 
>
> 如果, 本机就为 大端字节序存储, 则这些接口不会发生转换

## socket编程接口

socket编程有一些常见的API接口:

```c
// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)
int socket(int domain, int type, int protocol);

// 绑定端口号 (TCP/UDP, 服务器)
int bind(int socket, const struct sockaddr* address, socklen_t address_len);

// 开始监听socket (TCP, 服务器)
int listen(int socket, int backlog);

// 接收请求 (TCP, 服务器)
int accept(int socket, struct sockaddr* address, socklen_t* address_len);

// 建立连接 (TCP, 客户端)
int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);

// 发送报文 (UDP)
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);

// 接收报文 (UDP)
ssize_t recvfrom(int socket, void* restrict buffer, size_t length, int flags, struct sockaddr* restrict address, socklen_t* restrict address_len);
```

仔细观察这些接口. 可以发现, 除了监听socket和创建socket接口, 其他接口的参数中 都存在一个的参数类型: **`struct sockaddr`**.

### **`struct sockaddr`**

sockaddr 是一个结构体, 这个结构体的作用是什么呢?

套接字通信在设计的时候, 不仅实现了网络间通信, 也实现了本机内进程的通信

所以, 套接字我们通常分为两类: 网络套接字 和 域间套接字, 分别用于网络通信和本地(域间)通信

> 使用域间套接字可以实现本地进程的通信, 与之前介绍的 管道通信、共享内存通信 的功能大致相同. 域间通信也可以称为 `双向管道`.
>
> 域间套接字的使用 要比 网络套接字的使用简单, 因为域间套接字没有IP的概念, 没有端口号的概念. 在使用时, 只需要提供一个文件的路径, 与命名管道听起来一样, 但是实际操作是不同的.

套接字的设计分成了两类, 那么使用套接字实现进程通信的接口也分别实现了网络通信和本体通信两种吗?

其实并没有, 如果设计成两套接口就太复杂了, 既然都是套接字, 设计者就将网络套接字和域间套接字的通信接口统一起来了

但是问题又出现了, 实现网络通信和域间通信 需要的资源是不同的:

1. 使用网络套接字实现网络通信, 需要 IP地址、端口号等资源, 所以设计了 `struct sockaddr_in` 等结构体, 来描述网络通信所需资源
2. 使用域间套接字实现域间通信, 需要 路径名 等资源, 所以设计了 `struct sockaddr_un` 结构体, 来描述域间通信所需资源

![|inline](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306281619679.png)

> `struct sockaddr_in` 的前16位 是一个宏, **`AF_INET`**
>
> `struct sockaddr_un` 的前16位 同样是一个宏, **`AF_UNIX`**

所需要的资源不同, 也就是说需要传递给接口的资源不同

但是 网络套接字和域间套接字的接口是统一的, 那么 一个接口该如何接收不同类型的数据呢?

既然, 接口 **需要接收不同类型的数据**, 那么就 **不能将接口的参数设置为 上面的具体的描述资源的结构体**

而且, 上面列举出的接口的参数 并没有 `struct sockaddr_in` 或 `struct sockaddr_un` 类型的, 而有一个 `struct sockaddr`

那么, `struct sockaddr` 这个结构体究竟是什么呢?

此结构体的内容是这样的:

![|inline](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306281633081.png)

单独看好像没有什么特殊的. 当 此结构体和 另外的结构体对比的时候:

![|inline](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306281644752.png)

可以发现, 这三个结构体的首16位 都指 **`地址类型`**

> 地址类型, 不同的宏可以 区分协议 以及 区分网络通信还是域间通信
>
> **`AF_INET`** 用于 IPv4，**`AF_INET6`** 用于 IPv6
>
> 如果是 `域间通信`, 则 此地址类型为 **`AF_UNIX`**

其实, `struct sockaddr` 是设计出来的一个抽象的中间结构体. 使用在接口中就是为了能够让接口接收不同类型的数据资源

在使用 `socket` 接口的时候, 需要先将 `struct sockaddr_in*` 或 `struct sockaddr_un*` 等类型的结构体, 强转为 `struct sockaddr*` 然后再传给接口使用. 

因为 `sockaddr` 类似的结构体的前16位都表示地址类型. 

所以, **接口接收到传来的数据之后, 会根据 前16 的地址类型 来区分协议以及通信方式, 更会根据地址类型判断出数据的原结构体类型, 然后将 `sockaddr` 结构体 强转回 原结构体类型, 以获取完整的通信信息**

### 接口演示: 简单的UDP网络通信

通过一部分接口的参数, 我们介绍了三个结构体(`struct sockaddr`、`struct sockaddr_in`和`struct sockaddr_un`). 了解到了, 这三个结构体是用来存储网络信息的. 在使用套接字接口的时候, 需要将所需的网络信息传递给接口.

下面, 我们就通过实现一个简单的UDP网络通信 演示一部分接口.

演示接口之前, 还要先简单的介绍几个接口:

#### 1. `int socket()`

```c
int socket(int domain, int type, int protocol);
```

`socket()` 的作用是 创建一个socket文件描述符. man 手册中是这样介绍的:

![man For socket](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306301607179.png)

使用一个接口, 肯定要先了解它的参数, socket()有三个参数:

1. `int domain`

    我们介绍 `sockaddr` 相关结构体时, 演示 结构体的前16位 是地址类型. 通常是一个宏, 用来区分协议以及通信方式的.

    而这里的第一个参数 `int domain`, 就是传入地址类型 区分通信方式的. 被称作 `socket的域`

    ![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306301613672.png)

    其中, **`AF_UNIX`** 和 **`AF_LOCAL`** 相同. 传入之后 都表示本地通信

    而 **`AF_INET`** 表示 ipv4网络通信, **`AF_INET6`** 则表示 ipv6网络通信

    最常用的, 其实就只有 **`AF_UNIX`** 和 **`AF_INET`**

2. `int type`

    此参数是用来选择 **套接字类型** 的, 决定了通信时候对应的 **`报文类型`**. 

    ![|wide](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306301656128.png)

    其中, 前四个 **`SOCK_STREAM`** **`SOCK_DGRAM`** **`SOCK_SEQPACKET`** **`SOCK_RAW`** 是最常用的

    1. **`SOCK_STREAM`**, 表示 流式套接字. 一般用于TCP

    2. **`SOCK_DGRAM`**, 表示 数据报式套接字. 一般用于UDP

    3. **`SOCK_SEQPACKET`**, 表示 连续数据报套接字.

    4. **`SOCK_RAW`**, 表示 原始套接字. 使用此套接字, 通信可以直接绕过传输层的协议, 直接访问IP协议.

        不过, 绕过传输层协议, 就表示需要自己实现一些传输协议的内容. 一般用于网络诊断等方面

3. `int protocol`

    这个参数用来选择 **协议类型**. 

    此参数的选择 与 第二个参数 `type` 密切相关. 

    比如, `type` 传入 **`SOCK_STREAM`** 此参数就需要传入 **`IPPROTO_TCP`**, 就选择了 TCP协议

    但实际上, 我们不需要手动使用宏去选择. 网络通信时, 选定 `type` 并且只需要使用一种协议时, `protocol` 可以直接传入`0`, 表示使用默认协议, 其实就是操作系统根据前面的参数选择的最适用的协议.

    文章中在使用时, 一定都设置为`0`了

了解了 `socket()` 的参数之后, 还需要了解一下它的返回值.

![|inline](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/202306301754510.png)

如果成功了, 就返回 **`新套接字的文件描述符`**. 如果错误, 就返回 -1, 并设置 `errno`
